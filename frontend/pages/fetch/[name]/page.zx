const std = @import("std");

const zx = @import("zx");

const api = @import("api");

const wasm = @import("../../../wasm.zig");

var name: []const u8 = undefined;
var id: u64 = undefined;

var count: zx.Signal(u64) =.init(0);
var ms: zx.Signal(u64) = .init(0);
var updater: zx.Effect(u64) = .init(&count, update);

fn updateCallback(response: api.fetch.status.Output) !void {
    count.set(response.count);
    ms.set(response.ms_elapsed);
}

fn update(_: u64) !void {
    try wasm.api.execute(
        api.fetch.status,
        wasm.allocator,
        "/api/fetch/status",
        updateCallback,
        .{
            .id = id,
        },
    );
}

fn startCallback(response: api.fetch.start.Output) !void {
    id = response.id;
    count.set(0);
}

pub fn Stats(allocator: zx.Allocator) zx.Component {
    if (!wasm.inClient()) {
        return (<></>);
    }

    wasm.api.execute(
        api.fetch.start,
        allocator,
        "/api/fetch/start",
        startCallback,
        .{
            .name = name,
        },
    ) catch |err| {
        return (
            <>
                Error launching task in server: {@errorName(err)}
            </>
        );
    };

    return (
        <fragment @{allocator}>
            Found {&count} cards in {&ms}ms
        </fragment>
    );
}

pub fn Page(ctx: zx.PageContext) !zx.Component {
    name = ctx.request.getParam("name") orelse return error.MissingName;

    return (
        <div @allocator={ctx.arena}>
            <Stats @rendering={.client} />
        </div>
    );
}

const std = @import("std");
const Allocator = std.mem.Allocator;

const zx = @import("zx");

const backend = @import("backend");

const Size = union(enum) {
    pixels: u16,
    percentage: u7,

    pub fn toHtml(self: Size, allocator: Allocator) ![]const u8 {
        return switch (self) {
            .pixels => |pixels| std.fmt.allocPrint(allocator, "{}px", .{pixels}),
            .percentage => |percentage| std.fmt.allocPrint(allocator, "{}%", .{percentage}),
        };
    }
};

pub const ImageSize = union(enum) {
    height: Size,
    width: Size,

    pub fn toHtml(self: ImageSize, allocator: Allocator) ![]const u8 {
        return switch (self) {
            .height => |height| std.fmt.allocPrint(allocator, "height: {s}", .{try height.toHtml(allocator)}),
            .width => |width| std.fmt.allocPrint(allocator, "width: {s}", .{try width.toHtml(allocator)}),
        };
    }
};

fn title(allocator: std.mem.Allocator, value: anytype) ![]const u8 {
    const str = @tagName(value);
    const copy = try allocator.dupe(u8, str);

    const lower = std.ascii.lowerString(copy, str);
    lower[0] = std.ascii.toUpper(lower[0]);

    return lower;
}

pub fn Image(
    allocator: zx.Allocator,
    props: struct {
        card: backend.Card,
        size: ImageSize = .{ .width = .{ .pixels = 150 } },
    },
) !zx.Component {
    return (<img @{allocator} src={props.card.image_url} aria-label={props.card.name} alt="image not found" style={try props.size.toHtml(allocator)} loading="lazy" />);
}

fn stringLessThan(lhs: []const u8, rhs: []const u8) bool {
    // foo-8 must be prior to foo-10, can't lexicographically sort on diff len
    if (lhs.len < rhs.len) return true;
    if (lhs.len > rhs.len) return false;

    return std.mem.order(u8, lhs, rhs) == .lt;
}

fn cardLessThanInner(sets: []const backend.Card.Set, lhs: backend.Card, rhs: backend.Card) !bool {
    // compare tcgdex id, not great due to lack of leading '0' for padding
    if (lhs.set_id == rhs.set_id) {
        return stringLessThan(lhs.tcgdex_id, rhs.tcgdex_id);
    }

    const lhs_set = for (sets) |set| {
        if (lhs.set_id == set.id) break set;
    } else return error.SetNotFound;

    const rhs_set = for (sets) |set| {
        if (rhs.set_id == set.id) break set;
    } else return error.SetNotFound;

    return stringLessThan(lhs_set.release_date, rhs_set.release_date);
}

fn cardLessThan(sets: []const backend.Card.Set, lhs: backend.Card, rhs: backend.Card) bool {
    return cardLessThanInner(sets, lhs, rhs) catch true;
}

pub fn Cards(
    allocator: zx.Allocator,
    props: struct {
        cards: []const backend.Card,
    },
) !zx.Component {
    var session = try backend.database.getSession(allocator);
    defer session.deinit();

    const sets = try backend.database.findAll(backend.Card.Set, &session, .{});

    const cards = try allocator.dupe(backend.Card, props.cards);
    std.mem.sort(backend.Card, cards, sets, cardLessThan);

    return (
        <div @{allocator}>
            {if (cards.len == 0) "No cards found" else (
                <div class="grid lg:grid-cols-10 md:grid-cols-8 sm:grid-cols-6 gap-1">
                    {for (cards) |card| (
                        <a href=`/card/{card.tcgdex_id}`>
                            <Image {card} />
                        </a>
                    )}
                </div>
            )}
        </div>
    );
}

pub fn Variant(
    allocator: zx.Allocator,
    props: struct {
        variant: backend.Card.Variant,
    },
) !zx.Component {
    return (
        <div @{allocator}>
            {try title(allocator, props.variant.type)}

            {if (props.variant.size) |size| if (size != .standard) (
                <>
                    {try title(allocator, size)}
                </>
            )}

            {if (props.variant.stamps.items.len > 0) (
                <>
                    Stamps: {for (props.variant.stamps.items) |stamp| (
                        <>
                            {try title(allocator, stamp)}
                        </>
                    )}
                </>
            )}

            {if (props.variant.foil) |foil| (
                <>
                    Foil: {try title(allocator, foil)}
                </>
            )}
        </div>
    );
}

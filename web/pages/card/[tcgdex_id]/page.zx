const std = @import("std");

const zx = @import("zx");
const js = zx.Client.js;

const app = @import("app");
const database = @import("database");

const cards = @import("../../../components/cards.zx");
const Image = cards.Image;

const wasm = @import("../../../wasm.zig");

const Owned = enum {
    not_logged,
    yes,
    no,
};

fn onCompletion(_: js.Object) !void {
    const window: js.Object = try js.global.get(js.Object, "window");
    const location: js.Object = try window.get(js.Object, "location");
    try location.call(void, "reload", .{});
}

fn onClickInner(ctx: zx.EventContext) !void {
    const target = ctx.getEvent().getTarget() orelse return;

    const url = try target.callAlloc(
        js.String,
        wasm.allocator,
        "getAttribute",
        .{js.string("url")},
    );

    const variant_id = try target.callAlloc(
        js.String,
        wasm.allocator,
        "getAttribute",
        .{js.string("variant_id")},
    );

    const api = try std.fmt.allocPrint(
        wasm.allocator,
        "{s}/{s}",
        .{ url, variant_id },
    );
    defer wasm.allocator.free(api);

    try wasm.api.execute(api, onCompletion);
}

fn onClick(ctx: zx.EventContext) void {
    if (zx.platform != .browser) return;
    onClickInner(ctx) catch {};
}

pub fn Button(
    allocator: zx.Allocator,
    props: struct {
        is_owned: bool,
        variant_id: i64, // should be database.Id but WASM can't "link" `database` module
        variant_text: []const u8,
    },
) !zx.Component {
    // NOTE: `/` in URL will be added in onClick's handler
    const class, const url = if (props.is_owned)
        .{ "text-green-600", "/api/missing" }
    else
        .{ "text-red-600", "/api/owned" };

    return (
        <button @{allocator} onclick={onClick} {class} {url} variant_id={props.variant_id}>
            {props.variant_text}
        </button>
    );
}

pub fn Page(ctx: app.PageCtx) !zx.Component {
    const tcgdex_id = ctx.request.getParam("tcgdex_id") orelse return error.MissingTcgdexId;

    var session = try ctx.app.pool.getSession(ctx.arena);
    defer session.deinit();

    const maybe_user = try ctx.state.getUser(&session);

    const card = try session
        .query(database.Card)
        .findBy("tcgdex_id", tcgdex_id) orelse return error.UnknownCard;

    const set = try session
        .query(database.Set)
        .findBy("tcgdex_id", card.set_id) orelse return error.UnknovwnSet;

    const variants = try card.getVariants(&session);

    const img_size: cards.ImageSize = .{ .width = .{ .pixels = 400 } };

    return (
        <div @allocator={ctx.arena} class="w-full items-center">
            <p class="text-7xl">
                {card.name} (<a href=`/set/{set.tcgdex_id}`>{set.name}</a>)
            </p>

            <span class="pb-10" />

            <div class="w-full h-full flex items-center">
                {if (card.cardmarket_id) |id| (
                    <a href=`https://www.cardmarket.com/Pokemon/Products?idProduct={id}` title="go to cardmarket">
                        <Image {card} size={img_size} />
                    </a>
                ) else (
                    <Image {card} size={img_size} />
                )}

                <span class="pr-10" />

                <div class="flex flex-col justify-center">
                    {for (variants) |variant| (
                        <div>
                            {if (maybe_user) |user| (
                                <Button @rendering={.client} is_owned={try variant.ownedBy(&session, user.id)} variant_id={variant.id} variant_text={try variant.toString(ctx.arena)} />
                            ) else (
                                <>
                                    {try variant.toString(ctx.arena)}
                                </>
                            )}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}

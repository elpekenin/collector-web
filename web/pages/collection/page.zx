const std = @import("std");

const zx = @import("zx");
const js = zx.Client.js;

const api = @import("api");
const app = @import("app");
const database = @import("database");

const wasm = @import("../../wasm.zig");

// const text = await response.text()
fn onText(text: js.Object) !void {
    const slice = try text.value.string(wasm.allocator);

    const parsed: std.json.Parsed(api.Tracked) = try std.json.parseFromSlice(
        api.Tracked,
        wasm.allocator,
        slice,
        .{},
    );
    defer parsed.deinit();

    const element: js.Object = .{
        .value = @enumFromInt(parsed.value.js_ref),
    };

    try element.set("className", js.string(styleFor(parsed.value.tracked)));
    try element.call(
        void,
        "setAttribute",
        .{
            js.string("base_url"),
            js.string(urlFor(parsed.value.tracked)),
        },
    );
}

// const response = await fetch("/api")
fn onResponse(response: js.Object) !void {
    try wasm.text(response, onText);
}

fn onClickInner(ctx: zx.EventContext) !void {
    const target = ctx.getEvent().getTarget() orelse return;

    const base_url = try target.callAlloc(
        js.String,
        wasm.allocator,
        "getAttribute",
        .{js.string("base_url")},
    );
    defer wasm.allocator.free(base_url);

    const pokedex = try target.callAlloc(
        js.String,
        wasm.allocator,
        "getAttribute",
        .{js.string("pokedex")},
    );
    defer wasm.allocator.free(pokedex);

    const url = try std.fmt.allocPrint(
        wasm.allocator,
        "{s}/{s}/{}",
        .{ base_url, pokedex, @intFromEnum(target.value) },
    );
    defer wasm.allocator.free(url);

    try wasm.fetch(url, onResponse);
}

fn onClick(ctx: zx.EventContext) void {
    if (zx.platform != .browser) return;
    onClickInner(ctx) catch {};
}

const ButtonProps = struct {
    is_tracked: bool,
    pokedex: api.database.Id,
    text: []const u8,
};

fn urlFor(is_tracked: bool) []const u8 {
    return if (is_tracked)
        "/api/untrack"
    else
        "/api/track";
}

fn styleFor(is_tracked: bool) []const u8 {
    // NOTE: `/` in URL will be added in onClick's handler
    return if (is_tracked)
        "text-green-600"
    else
        "";
}

pub fn Button(allocator: zx.Allocator, props: ButtonProps) !zx.Component {
    return (
        <button @{allocator} onclick={onClick} class={styleFor(props.is_tracked)} base_url={urlFor(props.is_tracked)} pokedex={props.pokedex}>
            {props.text}
        </button>
    );
}

pub fn Buttons(
    allocator: zx.Allocator,
    props: struct { buttons: []const ButtonProps },
) !zx.Component {
    return (
        <div @{allocator} class="flex flex-col">
            {for (props.buttons) |button| (
                <Button {..button} />
            )}
        </div>
    );
}

pub fn Page(ctx: app.PageCtx) !zx.Component {
    var session = try ctx.app.pool.getSession(ctx.arena);
    defer session.deinit();

    const user = try ctx.state.getUser(&session) orelse {
        return (
            <>
                Must be logged in to access this page
            </>
        );
    };

    const all_species = try session
        .query(database.Species)
        .orderBy(.pokedex, .asc)
        .findAll();

    const buttons = try ctx.arena.alloc(ButtonProps, all_species.len);
    for (all_species, 0..) |species, i| {
        buttons[i] = .{
            .is_tracked = try user.isTracking(&session, species),
            .pokedex = species.pokedex,
            .text = species.name,
        };
    }

    return (
        <div @allocator={ctx.allocator} class="flex flex-col">
            <a href="/progress">
                See your progress
            </a>

            <Buttons @rendering={.client} {buttons} />
        </div>
    );
}

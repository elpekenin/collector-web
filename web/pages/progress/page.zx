const std = @import("std");

const zx = @import("zx");

const app = @import("app");
const database = @import("database");

const Cards = @import("../../components/cards.zx").Cards;
pub const CopyText = @import("../../components/copy.zx").CopyText;

fn textSummary(
    allocator: std.mem.Allocator,
    session: *database.Session,
    user_id: database.Id,
    cards: []const database.Card,
) ![]const u8 {
    var aw: std.Io.Writer.Allocating = .init(allocator);
    defer aw.deinit();

    const writer = &aw.writer;

    for (cards) |card| {
        try writer.print("{s}({s})\n", .{ card.name, card.tcgdex_id });

        const variants = try card.getVariants(session);
        for (variants) |variant| {
            const owned = try variant.ownedBy(session, user_id);
            if (owned) continue;

            const variant_str = try variant.toString(allocator);
            defer allocator.free(variant_str);

            try writer.print("  {s}\n", .{variant_str});
        }
    }

    return aw.toOwnedSlice();
}

pub fn Page(ctx: app.PageCtx) !zx.Component {
    var session = try ctx.app.pool.getSession(ctx.arena);
    defer session.deinit();

    const user = try ctx.state.getUser(&session) orelse {
        return (
            <>
                Must be logged in to access this page
            </>
        );
    };

    const cards = try user.getTrackedCards(&session);
    if (cards.len == 0) {
        return (
            <div>
                You are not tracking any species
            </div>
        );
    }

    const sets = try session
        .query(database.Set)
        .findAll();

    const sorted = try database.Card.sort(ctx.arena, cards, sets);

    const summary = try textSummary(ctx.arena, &session, user.id, sorted);

    return (
        <>
            <CopyText @rendering={.client} display="Copy missing cards to clipboard" content={summary} />
            <Cards cards={sorted} />
        </>
    );
}
